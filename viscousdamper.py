# -*- coding: utf-8 -*-
"""ViscousDamper.ipynb
Automatically generated by Colab.
Original file is located at
    https://colab.research.google.com/drive/1wcPXguSLQMmTcO30Ln6IwPHPvTJndN2_
"""
import openseespy.opensees as ops
import opsvis
import scipy.linalg as slin
N = 1
m = 1
sec = 1
g = 9.81* m/sec**2
kg = N/g
kN = 1000 *N
mm = m/1000
import numpy as np
# import re
# pattern = r"(\d+\.\d+e[+|-]\d+)\s+([-]?\d\.\d+e[+|-]\d+)"
# lines = []
# with open("elCentro_NS.txt") as text:
#   for texts in text.readlines():
#     for matched in re.findall(pattern, texts):
#       lines.append(matched)
# # print(lines[:3])
# timeSeries_N = []
# for line in lines:
#   timeSeries_N.append([float(line[0]), float(line[1])])
timeSeries_N = np.loadtxt("elCentroNS.txt")
time, timeSeries_N = timeSeries_N[:,0], timeSeries_N[:,1]
# timeSeries_N = np.array(timeSeries_N)
# time = timeSeries_N[:,0]
# timeSeries_N = timeSeries_N[:,1]
def buildModel(Viscous = True):
  ops.wipe()
  ops.model("Basic", "-ndm",2,"-ndf",3)
  ops.node(1,0.0*m,0.0*m)
  ops.node(2,5.0*m,0*m)
  ops.node(3,5.0*m,5.0*m)
  ops.node(4,0.*m,5.0*m)
  import numpy as np
  E = 25000 * N/mm**2
  nu = 0.3
  A = 300 *mm * 400 *mm
  I = 300 * 400**3/12 *mm**4
  ops.geomTransf("Linear",1)
  ops.element("elasticBeamColumn",1,1,4,A,E,I,1,"-mass",250000* kg * A,"-lmass")
  ops.element("elasticBeamColumn",2,4,3,A,E,I,1,"-mass",250000 * kg*A, "-lmass")
  ops.element("elasticBeamColumn",3,3,2,A,E,I,1,"-mass",250000 * kg*A,"-lmass")
  ops.mass(3,1000,1000,0)
  ops.mass(4,1000,1000,0)
  if Viscous:
    ops.uniaxialMaterial("Viscous",1,250000*2e3* kN/(m/sec), 1)
  # element('Truss', eleTag, *eleNodes, A, matTag, <'-rho', rho>, <'-cMass', cFlag>, <'-doRayleigh', rFlag>)
    ops.element("Truss",4,1,3,0.01,1)
  ops.fix(1,1,1,1)
  ops.fix(2,1,1,1)
  timePeriod = 2*np.pi/np.sqrt(ops.eigen(2))
  # print(f"The natural time period are: {timePeriod}")
  ops.rayleigh(2*0.05*2*np.pi/timePeriod[0],0.,0.,0.)
def extractMatrices(Viscous = True):
  buildModel(Viscous)
#
# Define your model
#
  ops.wipeAnalysis()
  ops.system('FullGeneral')
  ops.analysis('Transient')
  # Mass
  ops.integrator('GimmeMCK',1.0,0.0,0.0)
  ops.analyze(1,0.0)
  # Number of equations in the model
  N = ops.systemSize() # Has to be done after analyze
  M = ops.printA('-ret') # Or use ops.printA('-file','M.out')
  M = np.array(M) # Convert the list to an array
  M.shape = (N,N) # Make the array an NxN matrix
  # Stiffness
  ops.integrator('GimmeMCK',0.0,0.0,1.0)
  ops.analyze(1,0.0)
  K = ops.printA('-ret')
  K = np.array(K)
  K.shape = (N,N)
  # Damping
  ops.integrator('GimmeMCK',0.0,1.0,0.0)
  ops.analyze(1,0.0)
  C = ops.printA('-ret')
  C = np.array(C)
  C.shape = (N,N)
  return [M,C,K]
def AnalysisGenerator(Viscous = True):    #Generate the analysis
  buildModel(Viscous)
  ops.timeSeries("Path",1,"-values",*timeSeries_N, "-time", *time , "-factor", 9.81*m/sec**2)
  ops.pattern("UniformExcitation",1,1,"-accel",1 )
  ops.constraints("Plain")
  ops.numberer("RCM")
  ops.system("SparseGeneral", "-piv")
  ops.test("NormDispIncr",1e-7,100)
  ops.integrator("Newmark",0.5,0.25)
  ops.algorithm("ModifiedNewton")
  ops.analysis("Transient")
  disp = []
  velocity = []
  viscousForce = []
  for i in time:
    ops.analyze(1,np.diff(time)[0])
    disp.append(ops.nodeDisp(3,1))
    velocity.append(ops.nodeVel(3,1))
    viscousForce.append(ops.eleResponse(4, "axialForce"))
  return [viscousForce, velocity, disp,time]
viscousForce = 0
velocity = 1
disp = 2
x = 3
withViscous = AnalysisGenerator(Viscous = True)
withoutViscous = AnalysisGenerator(Viscous = False)
from matplotlib import pyplot as plt
plt.figure(figsize = (10,20))
plt.subplot(5,1,1)
plt.title("Velocity against Viscous Force")
plt.plot(withViscous[velocity], withViscous[viscousForce], "o", "orange", label = "with viscous damper")
# plt.plot(withoutViscous[velocity], withoutViscous[viscousForce],"blue","--", label = "without viscous damper")
plt.legend()
plt.subplot(5,1,2)
plt.title("Velocity against Displacement")
plt.plot(withViscous[velocity], withViscous[disp],"orange","--", label = "with viscous damper")
plt.plot(withoutViscous[velocity], withoutViscous[disp],"blue", label = "without viscous damper")
plt.legend()
plt.subplot(5,1,3)
plt.title("Displacement against Viscous Force")
plt.plot(withViscous[disp], withViscous[viscousForce],"orange", label = "with viscous damper")
plt.plot(withoutViscous[disp], withoutViscous[viscousForce],"blue", label = "without viscous damper")
plt.legend()
plt.subplot(5,1,4)
plt.title("Time against Displacement")
# plt.plot(withViscous[x], withViscous[disp],"orange", label = "with viscous damper", linewidth = 1.0)
plt.plot(withoutViscous[x], withoutViscous[disp],"blue", label = "without viscous damper", linewidth = 0.5)
plt.legend()
plt.subplot(5,1,5)
plt.title("Time against Displacement")
plt.plot(withViscous[x], withViscous[disp],"orange", label = "with viscous damper", linewidth = 1.0)
# plt.plot(withoutViscous[x], withoutViscous[disp],"blue", label = "without viscous damper", linewidth = 0.5)
plt.legend()
plt.show()
M,C,K = extractMatrices(Viscous = True)


np.savetxt("MCKFolder/K_or.txt",K)

# Now starting state space block
massDOFs = []
NDF = 3
for node in ops.getNodeTags():
  for j in range(NDF):
    if ops.nodeMass(node,j+1)>0.0:
      massDOFs.append(ops.nodeDOFs(node)[j])

N = ops.systemSize()
Nmass = len(massDOFs)
print(massDOFs)
masslessDOFs = np.setdiff1d(range(N),Nmass)
NmasslessDOFs  = len(masslessDOFs)
Kmm = K[massDOFs,:][:,massDOFs];     Kmn = K[massDOFs,:][:,masslessDOFs]
Knm = K[masslessDOFs,:][:,massDOFs]; Knn = K[masslessDOFs,:][:,masslessDOFs]
# Kc = Kmm - Kmn*inv(Knn)*Knm
if NmasslessDOFs > 0:
    K_condensed = Kmm - np.dot(Kmn,np.linalg.solve(Knn,Knm))
else:
    K_condensed = K
# kmm = K[massDOFs,:][:,massDOFs]
# kmn = K[massDOFs,:][:,masslessDOFs]
# knn = K[masslessDOFs,:][:,masslessDOFs]
# knm = kmn.T

# print(knm == kmn)
# if NmasslessDOFs> 0:
#   K_condensed = kmm - np.dot(kmn,np.linalg.inv(knn)@knm)
#   Mass = M[massDOFs,:][:,massDOFs]
#   C_eff = C[massDOFs,:][:,massDOFs]
# else:
#   K_condensed = K
#   Mass = M
#   C_eff = C

# 
# Hor_DOFs = [massDOFs[i] for i in range(Mass.shape[0]) if not i%2 ]  #assume there is no mass defined along the rotational dofs
# print(Hor_DOFs)

# np.savetxt("MCKFolder\M.txt",Mass)
# np.savetxt("MCKFolder\C.txt",C_eff)
np.savetxt("MCKFolder\K.txt",K_condensed)
np.savetxt("MCKFolder\Hor_DOFs.txt",massDOFs)
